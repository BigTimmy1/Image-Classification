# -*- coding: utf-8 -*-
"""Flower_Photo_Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ysm9tct1tyeZdTFsyDFcybBqzT1EY2JV
"""

import pandas as pd
import numpy as np
import tensorflow as tf
from tensorflow.keras import Sequential, layers
from tensorflow.keras.utils import image_dataset_from_directory

from sklearn.preprocessing import MinMaxScaler

import matplotlib.pyplot as plt
import os

from google.colab import drive
drive.mount('/content/gdrive')

dataset_dir = '/content/gdrive/MyDrive/Colab Notebooks/flower_photos/'

batch_size = 500
image_height = 250
image_width = 250

data = image_dataset_from_directory(dataset_dir,batch_size=batch_size, shuffle=False)

class_counts = {}

for class_name in os.listdir(dataset_dir):
    class_path = os.path.join(dataset_dir, class_name)
    if os.path.isdir(class_path):
        class_count = len(os.listdir(class_path))
        class_counts[class_name] = class_count

# Print the class counts
for class_name, count in class_counts.items():
    print(f"Class {class_name}: {count} items")

import random, shutil
from tensorflow.keras.preprocessing.image import img_to_array, load_img
from keras.utils import to_categorical

classes = os.listdir(dataset_dir)
classes

X = []
y = []

for label_index, label in enumerate(classes):
    label_path = os.path.join(dataset_dir, label)

    # Get a list of image filenames in the class folder
    image_names = os.listdir(label_path)
    for image_name in image_names[:batch_size]:
        image_path = os.path.join(label_path, image_name)
        image = load_img(image_path, target_size=(image_height, image_width))  # Adjust target_size as needed
        X.append(img_to_array(image))
        y.append(label_index)
X = np.array(X)
y = np.array(y)

X /= 255.0
y = to_categorical(y, num_classes=len(classes))

def display_images(images, labels, class_names, num_images=5):
    plt.figure(figsize=(15, 8))

    for i in range(num_images):
        index = random.randint(0, len(images) - 1)
        image = images[index]
        label = labels[index]
        class_name = class_names[np.argmax(label)]

        plt.subplot(1, num_images, i + 1)
        plt.imshow(image)
        plt.title(class_name)
        plt.axis('off')

    plt.show()

display_images(X, y, classes)

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.8, random_state=42)

import keras

from keras import Sequential
from keras.layers import Dense, Conv2D, MaxPooling2D, Dropout
from keras.layers import Flatten, Dropout
from keras.utils import to_categorical
from keras.utils import image_dataset_from_directory
from keras.utils import img_to_array

model = Sequential()
model.add(Conv2D(16, (3,3), 1, activation='relu', input_shape=(image_height, image_width, 3)))
model.add(MaxPooling2D())
model.add(Conv2D(32, (3,3), 1, activation='relu'))
model.add(MaxPooling2D())
model.add(Conv2D(16, (3,3), 1, activation='relu'))
model.add(MaxPooling2D())
model.add(Flatten())
model.add(Dropout(0.2))
model.add(Dense(256, activation='relu'))
model.add(Dense(5, activation='softmax'))

model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

epoch = 15
model.fit(X_train, y_train, epochs=epoch)

loss, acc = model.evaluate(X_test, y_test, verbose=2)
print('Loss: {:.3f}\nAccuracy: {:.3f}'.format(loss, acc))

y_train

y_pred_probabilities = model.predict(X_test)

# Convert probabilities to class labels (if you have a multi-class classification problem)
y_pred_classes = np.argmax(y_pred_probabilities, axis=1)
y_pred_classes = np.array(y_pred_classes)
# y_test_classes = to_categorical(y_test,num_classes=5)

y_test_classes = np.argmax(y_test, axis=1)

y_test_classes

from sklearn.metrics import multilabel_confusion_matrix, confusion_matrix

y_pred_flat = np.argmax(y_pred_classes, axis=-1).flatten()

# Flatten the y_true to get the true labels for each sample
y_true_flat = y_test.flatten()

# Compute multilabel confusion matrix
conf_matrix = multilabel_confusion_matrix(y_test_classes, y_pred_classes)

model.save('flower_photos.h5')

model.save('CNN_TM.keras')

# Download the saved model file
from google.colab import files
files.download('flower_photos.h5')